# 第九章 指针
## 一、取地址运算
1. **运算符&**
   - 获得==变量==的地址
   - 地址的类型为`%p`（在32位操作系统中占4个字节）
   - &不能对没有地址的东西取地址（如a+b、a++）
## 二、指针
1. **指针**
   - 保存地址的变量  
     `int i;`
     `int* p = &i;`
     `int* p, q; //  p的类型是指针，q的类型是整数`
     `int *p, q;`
2. **指针变量**
   - 变量的值是内存的地址
3. **作为参数的指针**
   - `void f(int *p);`
   - 被调用时得到某个变量的地址
   - 在函数中可以通过指针访问外面的i
4. **访问地址变量**
   - *是一个单目运算符，用来访问指针的值所表示的地址上的变量
## 三、指针的使用
1. **应用场景一**
   - 交换两个变量的值
   ```c
   void swap(int *a, int *b)
   {
       int temp = *a;
       *a = *b;
       *b = temp;
   }
   ```
2. **应用场景二** 
   - 函数需要返回多个值
   - 函数返回运算的状态，结果通过指针返回
     - 如：除法函数，成功时返回0，失败（除数为0）时返回1
3. **野指针**
   - 定义了指针变量，但没有指向任何变量，就开始使用指针
## 四、指针与数组
1. **传入函数的数组组成**
   - 函数参数表中的数组实际上是指针
     - `sizeof(a) == sizeof(int*);`
     - 可以用数组的运算符`[]`进行运算
2. **数组变量是特殊的指针**
   - 数组变量本身表达地址，所以
      - `a == &a[0];`
   - `[]`运算符可以对指针做
      - `p[0] == a[0];`
   - `*`运算符可以对数组做
      - `*a = 25;`    
   - 数组变量是const的指针，即常量指针，因此不能被赋值
      - `int a[] <==> int * const a = ...;`
## 五、指针与const
1. **指针是const**
   - `int * const q = &i`
   - `*q = 26;  //  OK`
   - `q++;  //  ERROR`
2. **所指是const**
   - `const int *p = &i`
   - `*p = 26;  //  ERROR`
   - `i = 26;   //  OK`
   - `p = &j;   //  OK`  
 
<font face='楷体' color=red> const\*p是固定\*p的数值，但\*p的地址可以改变；\*const p是固定\*p的地址，但\*p的数值可以改变</font>  

3. **保护数组值**
   - 设置参数为`const int a[]`
## 六、指针运算
1. **指针的加减法**
   - `*(p + n) <==> ac[n]`
2. **两个指针相减**
   - `*p - *q <==> 差 / sizeof(类型)`
3. **\*p++**
   - 取出p所指的数据，并将p移至下一个位置
   - `++`的优先级大于`*`
   - 常用于数组类的连续空间操作
   1. 方案一
   ```c
   for(int i = 0; i < strlen(ac); i++)
   {
       printf("%d\n", ac[i]);
   }
   ``` 
   2. 方案二
   ```c
   //   数组的最后一个元素设为-1
   while(*p != -1)
   {
       printf("%d\n", *p++);
   }
   ``` 
4. **指针比较**
5. **0地址**
   - NULL是一个预定定义的符号，表示0地址（空间）
6. **指针的类型转换**
   - `void*`表示不知道指向什么东西的指针
     - 计算时与`char*`相同（但不相通）
   - 指针也可以转换类型
     - `int *p = &i; void *q = (void*)p;`
7. **指针用来做什么**
   - 需要传入较大的数据时用作参数
   - 传入数组后对数组做操作
   - 函数返回不止一个结果
     - 需要用函数修改多个变量
   - 动态申请的内存  
## 七、动态内存分配
1. **输入数据**
   - `int *a = (int*)malloc(n*sizeof(int));`
2. **例题**
   ```c
   #include<stdio.h>
   #include<stdlib.h>

   int main()
   {
      int number;
      int *a;
      int i;
      printf("输入数量：");
      scanf("%d", &number);
      //int a[number];
      a = (int *)malloc(number*sizeof(int));
      for(i = 0; i < number; i++)
      {
         scanf("%d", &a[i]);
      }
      free(a); // 释放内存
      return 0;
   }
   ``` 
   - 向`malloc`申请的空间的大小是以字节为单位的
   - 返回的类型是`void*`，需要类型转换
3. **注意事项**
   - 重复`free`
   - 地址更改后仍然`free`